{"componentChunkName":"component---src-templates-post-tsx","path":"/node-internal/","result":{"data":{"markdownRemark":{"html":"<p>혹시 Node.js 스크립트를 실행하면 어떤 방식으로 동작을 하는지 궁금하지 않았나요?</p>\n<p>이 글은 이런 궁금증을 가지고 있는 분들에게 조금이나마 도움이 되고자 하는 글이니, 관심이 없으시다면 스킵하셔도 됩니다 :D</p>\n<p>먼저, Node.js를 분석하기 위해서 코드를 다운 받아봅시다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">$ git clone https<span class=\"token operator\">:</span><span class=\"token operator\">/</span><span class=\"token operator\">/</span>github<span class=\"token punctuation\">.</span>com<span class=\"token operator\">/</span>nodejs<span class=\"token operator\">/</span>node<span class=\"token punctuation\">.</span>git <span class=\"token operator\">&amp;&amp;</span> cd node</code></pre></div>\n<p>Node.js의 파일 구조는 아래와 같은 모습을 가지고 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ tree -L <span class=\"token number\">1</span>\n<span class=\"token builtin class-name\">.</span>\n├── AUTHORS\n├── BSDmakefile\n├── BUILDING.md\n├── CHANGELOG.md\n├── CODE_OF_CONDUCT.md\n├── COLLABORATOR_GUIDE.md\n├── CONTRIBUTING.md\n├── CPP_STYLE_GUIDE.md\n├── GOVERNANCE.md\n├── LICENSE\n├── Makefile\n├── README.md\n├── SECURITY.md\n├── android-configure\n├── benchmark\n├── common.gypi\n├── configure\n├── configure.py\n├── deps\n├── doc\n├── lib           <span class=\"token comment\"># JS sources</span>\n├── node.gyp\n├── node.gypi\n├── src           <span class=\"token comment\"># C++ sources</span>\n├── <span class=\"token builtin class-name\">test</span>\n├── tools\n└── vcbuild.bat\n\n<span class=\"token number\">7</span> directories, <span class=\"token number\">20</span> files</code></pre></div>\n<p>노드는 크게 2종류의 언어로 이루어져 있는데 <code class=\"language-text\">lib/</code> 폴더 안에 있는 JavaScript 파일 들과 <code class=\"language-text\">src/</code> 폴더 밑에 존재하는 많은 양의 C++ 파일 들이 있습니다. </p>\n<p>Node.js의 모든 시작 과정은 C++에서 완료되며, main 시작 지점은 <code class=\"language-text\">src/node_main.cc</code> 입니다.</p>\n<p>이 안에서 제일 중요한 부분은 다음과 같습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">return node::Start(argc, argv);</code></pre></div>\n<p>이 것은 <code class=\"language-text\">src/node.cc</code>의 <code class=\"language-text\">Start</code>을 호출하고 command line의 parameter들을 <code class=\"language-text\">argc</code>와 <code class=\"language-text\">argv</code>로 넘겨줍니다.</p>\n<p>첫 번째 단계로 <code class=\"language-text\">Start()</code>안에서 런타임 초기화 작업들이 수행되는데 <code class=\"language-text\">InitializeOncePerProcess</code>는 환경변수(예.<code class=\"language-text\">NODE_OPTIONS</code>)나 CLI parameters(예.<code class=\"language-text\">--abort-on-uncaught-exception</code>)를 통해 주어지는 설정 값들을 처리하고 V8을 초기화 해준다. 한 번 이작업이 완료가 되면, 새로운 node 인스턴스들은 <a href=\"http://docs.libuv.org/en/v1.x/loop.html#c.uv_default_loop\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">libuv default loop</a>를 사용해 초기화 된 후 마침내 아래와 같이 실행되게 됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">NodeMainInstance main_instance(&amp;params,\n                               uv_default_loop(),\n                               per_process::v8_platform.Platform(),\n                               result.args,\n                               result.exec_args,\n                               indexes);\nresult.exit_code = main_instance.Run()</code></pre></div>\n<p><code class=\"language-text\">NodeMainInstance::Run()</code>을 통해 Node를 실행 시 어떤 일들이 수행되는 지를 알 수 있는 길에 좀 더 가까워졌습니다. 새로운 메인 쓰레드 수행 환경이 <code class=\"language-text\">src/node_main_instance.cc</code>에서 만들어지는데:</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">std::unique_ptr&lt;Environment&gt; env = CreateMainEnvironment(&amp;exit_code);</code></pre></div>\n<p>이 <code class=\"language-text\">Environment</code> 인스턴스가 libuv와 V8을 접근 할 수 있는 Handle들을 가지고 있는 노드 프로세스의 중심 객체입니다.</p>\n<p>이 객체를 <code class=\"language-text\">LoadEnvironment</code>에 넘기면</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">LoadEnvironment(env.get());</code></pre></div>\n<p>main thread 수행이 시작된다:</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">void LoadEnvironment(Environment* env) {\n  CHECK(env-&gt;is_main_thread());\n  USE(StartMainThreadExecution(env));\n}</code></pre></div>\n<p>이 부분에서 C++에서 JavaScript 수행으로 변경이 됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">MaybeLocal&lt;Value&gt; StartMainThreadExecution(Environment* env) {\n  if (NativeModuleEnv::Exists(&quot;_third_party_main&quot;)) {\n    return StartExecution(env, &quot;internal/main/run_third_party_main&quot;);\n  }\n\n  std::string first_argv;\n  if (env-&gt;argv().size() &gt; 1) {\n    first_argv = env-&gt;argv()[1];\n  }\n\n  if (first_argv == &quot;inspect&quot; || first_argv == &quot;debug&quot;) {\n    return StartExecution(env, &quot;internal/main/inspect&quot;);\n  }\n\n  if (per_process::cli_options-&gt;print_help) {\n    return StartExecution(env, &quot;internal/main/print_help&quot;);\n  }\n\n\n  if (env-&gt;options()-&gt;prof_process) {\n    return StartExecution(env, &quot;internal/main/prof_process&quot;);\n  }\n\n  // -e/--eval without -i/--interactive\n  if (env-&gt;options()-&gt;has_eval_string &amp;&amp; !env-&gt;options()-&gt;force_repl) {\n    return StartExecution(env, &quot;internal/main/eval_string&quot;);\n  }\n\n  if (env-&gt;options()-&gt;syntax_check_only) {\n    return StartExecution(env, &quot;internal/main/check_syntax&quot;);\n  }\n\n  if (!first_argv.empty() &amp;&amp; first_argv != &quot;-&quot;) {\n    return StartExecution(env, &quot;internal/main/run_main_module&quot;);\n  }\n\n  if (env-&gt;options()-&gt;force_repl || uv_guess_handle(STDIN_FILENO) == UV_TTY) {\n    return StartExecution(env, &quot;internal/main/repl&quot;);\n  }\n\n  return StartExecution(env, &quot;internal/main/eval_stdin&quot;);\n}</code></pre></div>\n<p><code class=\"language-text\">StartExecution</code>의 경우 두번째 인자로 넘겨지는 JS파일들을 읽고, 컴파일하고, 실행하는데 모든 파일은 <code class=\"language-text\">lib/</code> 폴더 밑에 있는데, 이중 관심있게 봐야하는 곳은 두 곳 입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">if (!first_argv.empty() &amp;&amp; first_argv != &quot;-&quot;) {\n  return StartExecution(env, &quot;internal/main/run_main_module&quot;);\n}</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">if (env-&gt;options()-&gt;force_repl || uv_guess_handle(STDIN_FILENO) == UV_TTY) {\n  return StartExecution(env, &quot;internal/main/repl&quot;);\n}</code></pre></div>\n<p><code class=\"language-text\">lib/internal/main/repl.js</code>와 <code class=\"language-text\">lib/internal/main/run_main_module.js</code> 두 스크립트 모두 중요한 시작 메소드인 <code class=\"language-text\">lib/internal/bootstrap/pre_execution.js</code>안의 <code class=\"language-text\">prepareMainThreadExecution</code>을 실행하는데, 이것은 여러 setup 작업들을 수행하는데 이 중 CommonJS와 ES module loader 초기화 역시 수행됩니다.</p>\n<p><code class=\"language-text\">lib/internal/modules/cjs/loader.js</code>안의 <code class=\"language-text\">Module</code> 객체는 CommonJS loaders core이며 <code class=\"language-text\">initializeCJSLoader</code>는 <code class=\"language-text\">runMain</code>를 통해 <code class=\"language-text\">lib/internal/modules/run_main.js</code>안의 <code class=\"language-text\">executeUserEntryPoint</code>을 실행해줍니다.</p>\n<p>CommonJS module의 경우 <code class=\"language-text\">Module._load</code>로 새로운 <code class=\"language-text\">Module</code> 인스턴스를 생성하고 <code class=\"language-text\">load</code>를 호출 해주고 적절한 extension function이 module을 읽어오는데 사용됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">Module<span class=\"token punctuation\">.</span>_extensions<span class=\"token punctuation\">[</span>extension<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> filename<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"language-text\">*.js</code> extension이 실제 파일을 읽고 컴파일 해줍니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> content <span class=\"token operator\">=</span> fs<span class=\"token punctuation\">.</span><span class=\"token function\">readFileSync</span><span class=\"token punctuation\">(</span>filename<span class=\"token punctuation\">,</span> <span class=\"token string\">'utf8'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nmodule<span class=\"token punctuation\">.</span><span class=\"token function\">_compile</span><span class=\"token punctuation\">(</span>content<span class=\"token punctuation\">,</span> filename<span class=\"token punctuation\">)</span></code></pre></div>\n<p><code class=\"language-text\">module._compile</code>은 V8의 <code class=\"language-text\">ScriptCompiler:CompileFunctionInContext</code>를 호출하고 <a href=\"https://nodejs.org/api/modules.html#modules_the_module_wrapper\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">node module wrapper</a>에 맞는 <code class=\"language-text\">exports</code>, <code class=\"language-text\">require</code>, <code class=\"language-text\">module</code>, <code class=\"language-text\">__filename</code>, <code class=\"language-text\">__dirname</code>을 넘겨줍니다.</p>\n<p>이렇게 불려진 function은 실행이 되고 결과를 리턴해줍니다:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">result <span class=\"token operator\">=</span> <span class=\"token function\">compiledWrapper</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>thisValue<span class=\"token punctuation\">,</span> exports<span class=\"token punctuation\">,</span> require<span class=\"token punctuation\">,</span> module<span class=\"token punctuation\">,</span>\n                              filename<span class=\"token punctuation\">,</span> dirname<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<hr>\n<p>다음으로 확인 해봐야할 부분은 <a href=\"http://docs.libuv.org/en/v1.x/guide/basics.html#event-loops\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">libuv eventloop</a>입니다.</p>\n<p>JavaScript를 컴파일하고 실행한 후, node 인스턴스는 event loop를 시작해줍니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">do {\n    uv_run(env-&gt;event_loop(), UV_RUN_DEFAULT);\n\n    per_process::v8_platform.DrainVMTasks(isolate_);\n\n    more = uv_loop_alive(env-&gt;event_loop());\n    if (more &amp;&amp; !env-&gt;is_stopping()) continue;\n\n    if (!uv_loop_alive(env-&gt;event_loop())) {\n        EmitBeforeExit(env.get());\n    }\n\n    // Emit `beforeExit` if the loop became alive either after emitting\n    // event, or after running some callbacks.\n    more = uv_loop_alive(env-&gt;event_loop());\n} while (more == true &amp;&amp; !env-&gt;is_stopping());</code></pre></div>\n<p><a href=\"http://docs.libuv.org/en/v1.x/loop.html#c.uv_run_mode\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">uv<em>run</em>mode</a> <code class=\"language-text\">UV_RUN_DEFAULT</code>는 더이상 동작하거나 참조되는 곳이 없을때 까지 event loop를 수행합니다.</p>\n<p>libuv는 lifetime에 따라 handle과 request로 구분이 되는데, 오랫동안 수행되는 객체의 경우 handle이라고 할 수 있고 짧은 시간동안 수행되는 operation들을 request라고 할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> http <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'http'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">requestHandler</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">req<span class=\"token punctuation\">,</span> res</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  res<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Hello World!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  res<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> server <span class=\"token operator\">=</span> http<span class=\"token punctuation\">.</span><span class=\"token function\">createServer</span><span class=\"token punctuation\">(</span>requestHandler<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nserver<span class=\"token punctuation\">.</span><span class=\"token function\">listen</span><span class=\"token punctuation\">(</span><span class=\"token number\">8080</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>위 예제의 경우 <code class=\"language-text\">requestHandler</code>를 libuv request로 볼 수 있습니다. 반면, <code class=\"language-text\">server</code> 객체의 <code class=\"language-text\">listen</code>은 handle이라고 할 수 있습니다.</p>\n<p>HTTP server를 멈추지 않는 이상, libuv는 계속해서 실행되고 입력되는 연결들을 처리할 것 입니다.</p>\n<hr>\n<p>위 과정들이 Node.js에서 스크립트가 어떻게 수행되는 지를 설명한 내용입니다. 물론, 전체 과정을 상세히 다루는게 아니기 때문에 설명이 부족한 부분이 있을 수 있겠지만, 스크립트가 수행되는 과정에서의 중요한 부분들을 설명해주고 있습니다.</p>\n<p>혹시 기회가 된다면 다음 포스트를 통해 추가적인 내용들을 다루어 보겠습니다.</p>\n<hr>\n<h2 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h2>\n<p><a href=\"https://blog.s1h.org/inside-node-executing-a-script/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Inside node: What happens when we execute a script?</a></p>","excerpt":"혹시 Node.js 스크립트를 실행하면 어떤 방식으로 동작을 하는지 궁금하지 않았나요? 이 글은 이런 궁금증을 가지고 있는 분들에게 조금이나마 도움이 되고자 하는 글이니, 관심이 없으시다면 스킵하셔도 됩니다 :D 먼저, Node.js…","tableOfContents":"<ul>\n<li><a href=\"/node-internal/#reference\">Reference</a></li>\n</ul>","fields":{"slug":"/node-internal/"},"frontmatter":{"title":"Node.js에서 스크립트가 실행될 때 어떤 일들이 일어날까요?","date":"Feb 16, 2020","tags":["Node.js"],"keywords":["Node.js"]}}},"pageContext":{"slug":"/node-internal/","series":[]}}}