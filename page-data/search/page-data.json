{"componentChunkName":"component---src-pages-search-tsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"\r\n### TAU Button 생성\r\n\r\nApp 개발시 많이 사용되는 Component 중 하나로 말 그대로 Button 이다.\r\n\r\nTAU에서 Button을 추가할 수 있는 방법은 아래와 같이 3가지 방법이 있다.\r\n\r\n``` html\r\n<div class=\"ui-page\">\r\n  <div class=\"ui-content\">\r\n    <!-- 3가지 버튼 생성 방법 이 중 하나 선택 -->\r\n    <button type=\"button\" class=\"ui-btn\">Button</button>\r\n    <a href=\"#\" class=\"ui-btn\">Button</a>\r\n    <input type=\"button\" class=\"ui-btn\" value=\"Button\"/>\r\n  </div>\r\n</div>\r\n```\r\n\r\n![](tizen1.png)\r\n\r\n### Button 속성\r\n\r\n기본적으로 Button을 표현하는 방법 외에도 아래 속성들을 넣어주면 추가 속성을 부여할 수 있다.\r\n\r\n| class | Description |\r\n|:--:|:--:|\r\n| ui-btn | Button Component를 만들기 위해 기본으로 추가되어야 하는 class |\r\n| ui-btn-icon | icon 스타일 button 생성 |\r\n| ui-inline | inline 스타일 button 생성 |\r\n| ui-multiline | multiline 스타일 button 생성 |\r\n\r\n### Icon 버튼\r\n\r\n텍스트를 가진 Button 외에도 아이콘 형식의 버튼을 만들기 위해서는 아래와 같은 형태로 입력해주면 된다. 기본 버튼 생성 class인 `ui-btn`에 `ui-btn-icon`을 추가해주면 된다. 사용할 아이콘 이미지의 위치는 `background-image` style의 url()안에 입력하면 된다.\r\n\r\n\r\n``` html\r\n  <button type=\"button\" class=\"ui-btn ui-btn-icon ui-btn-icon-middle\"\r\n    style=\"background-image: url(icon.png);\">\r\n  </button>\r\n```\r\n\r\n![](tizen3.png)\r\n\r\n### Inline 버튼\r\n\r\n일반 Button의 경우 한 줄 전체 크기로 생성이 되지만 inline 버튼의 경우 Text 크기만큼의 영역이 할당되는 버튼이다.\r\n기본 버튼 생성 class인 `ui-btn`에 `ui-inline`을 추가해주면 된다. \r\n\r\n``` html\r\n  <button type=\"button\" class=\"ui-btn\">Button</button>\r\n  <button type=\"button\" class=\"ui-btn ui-inline\">Inline</button>\r\n  <button type=\"button\" class=\"ui-btn ui-inline\">Inline</button>\r\n```\r\n\r\n![](tizen2.png)\r\n\r\n\r\n### 다중 line 버튼\r\n\r\n다중 line 버튼의 경우 텍스트를 여러 줄 가진 형식의 버튼을 만들고 싶을 경우 사용한다. 기본 버튼 생성 class인 `ui-btn`에 `ui-multiline`을 추가해주면 된다. \r\n\r\n``` html\r\n  <button type=\"button\" class=\"ui-btn ui-multiline\">Multiline<br/> Button</button>\r\n```\r\n\r\n![](tizen4.png)\r\n\r\n\r\n### 버튼 클릭시 색상 변경\r\n\r\n버튼 클릭시 표시되는 기본 생상을 다른 색으로 변경하고 싶다면 아래 표를 참고하여 변경하여주면 된다. `ui-btn`에 원하는 색상 class를 추가해주면 된다.\r\n\r\n| class | Default color | Pressed color | Disable color |\r\n|:--:|:--:|:--:|:--:|\r\n| ui-color-red | #ce2302 | #dd654e | #3d0a0a |\r\n| ui-color-orange | #ed8600 | #f0aa56 | #462805 |\r\n| ui-color-green | #64a323 | #92be5e | #1e3108 |\r\n\r\n\r\n``` html\r\n  <a href=\"#\" class=\"ui-btn ui-color-red\">Red Button</a>\r\n  <a href=\"#\" class=\"ui-btn ui-color-orange\">Orange Button</a>\r\n  <a href=\"#\" class=\"ui-btn ui-color-green\">Green Button</a>\r\n```\r\n\r\n![](tizen5.png)\r\n\r\n### 버튼 크기 설정\r\n\r\n버튼 크기를 원하는 크기의 비율로 배치하고 싶을 경우는 아래와 같이 `ui-grid-col-x`를 사용하여 크기를 정할 수 있다.\r\n\r\n| class | Description |\r\n|:--:|:--:|\r\n| ui-grid-col-1 | 버튼 가로 크기를 100%로 설정한다 |\r\n| ui-grid-col-2 | 버튼 가로 크기를 50%로 설정한다 |\r\n| ui-grid-col-3 | 버튼 가로 크기를 33%로 설정한다 |\r\n| ui-grid-row| 버튼을 가로 한줄 씩 사용하도록 정의한다 |\r\n\r\n``` html\r\n  <div class=\"ui-grid-col-1\">\r\n    <button type=\"button\" class=\"ui-btn\">100%</button>\r\n  </div>\r\n  <div class=\"ui-grid-col-2\">\r\n    <button type=\"button\" class=\"ui-btn\">50%</button>\r\n    <button type=\"button\" class=\"ui-btn\">50%</button>\r\n  </div>\r\n  <div class=\"ui-grid-col-3\">\r\n    <button type=\"button\" class=\"ui-btn\">33%</button>\r\n    <button type=\"button\" class=\"ui-btn\">33%</button>\r\n    <button type=\"button\" class=\"ui-btn\">33%</button>\r\n  </div>\r\n```\r\n\r\n![](tizen6.png)","excerpt":"TAU Button 생성 App 개발시 많이 사용되는 Component 중 하나로 말 그대로 Button 이다. TAU에서 Button을 추가할 수 있는 방법은 아래와 같이 3가지 방법이 있다.  Button 속성 기본적으로 Button…","fields":{"slug":"/tizen-4/"},"frontmatter":{"date":"Mar 30, 2020","title":"Galaxy Watch 앱 만들기 #4 - Button","tags":["Galaxy","Tizen","Gear","Watch","TAU","갤럭시워치","타이젠","Button"]}}},{"node":{"rawMarkdownBody":"\r\n## TAU Component 리스트\r\n\r\n앞서 [#2](https://hs85jeong.github.io/tizen-2/)에서 TAU를 어떻게 사용하면 되는지를 배웠다면, 이제 해야할 일은 TAU에서 제공하는 Component 들 중에 내가 개발할 App에 필요한 Component를 찾아야 하는 일이다. TAU에서 제공하는 Component들의 리스트는 [이곳](https://docs.tizen.org/application/web/api/4.0/ui_fw_api/Wearable_UIComponents/wearable_component_list.htm)에서 확인할 수 있다.\r\n\r\n현재 공식 Document 상에는 총 23가지의 기본 Component들을 제공하고 있다. 이 Component들의 사용법에 대해서 하나 하나씩 다루어 보도록 하겠다.\r\n\r\n- Wearable UI Components\r\n  - Button\r\n  - Checkbox and radio button\r\n  - Circle ProgressBar\r\n  - Circular Index scroll bar\r\n  - Date picker\r\n  - Drawer\r\n  - Index scroll bar\r\n  - List\r\n  - Marquee\r\n  - Number picker\r\n  - Page Indicator\r\n  - Popup\r\n  - Processing\r\n  - Progress\r\n  - Section changer\r\n  - Selector\r\n  - Slider\r\n  - SnapListview\r\n  - Swipe list\r\n  - Timer picker\r\n  - Toggle switch\r\n  - View Switcher\r\n  - Virtual list\r\n\r\n","excerpt":"TAU Component 리스트 앞서 #2에서 TAU를 어떻게 사용하면 되는지를 배웠다면, 이제 해야할 일은 TAU에서 제공하는 Component 들 중에 내가 개발할 App에 필요한 Component를 찾아야 하는 일이다. TAU…","fields":{"slug":"/tizen-3/"},"frontmatter":{"date":"Mar 29, 2020","title":"Galaxy Watch 앱 만들기 #3 - TAU Component 종류","tags":["Galaxy","Tizen","Gear","Watch","TAU","갤럭시워치","타이젠"]}}},{"node":{"rawMarkdownBody":"\r\n## TAU 란?\r\n\r\n일반적으로 Web Application은 html, css, js를 조합해서 개발을 하는데 Web 개발을 많이 경험해 본 개발자라면 손 쉽게 원하는 화면을 구성할 수 있겠지만, 초보자라면 쉽지 않기 때문에 원하는 화면을 쉽고 빠르게 구성하기 위해 [bootstrap](https://getbootstrap.com/)이나 [Semantic UI](https://semantic-ui.com/) 같은 UI Framework를 사용해서 개발을 한다.\r\n\r\n하지만, 이런 UI Framwork들은 모바일이나 태블릿 화면을 기준으로 만들어져 있기 떄문에 Watch에 맞는 구성을 지원하지 않는다. 이런 문제를 해결할 수 있는게 바로 [TAU(Tizen Advanced UI)](https://samsung.github.io/TAU/) 이다.\r\n\r\nTAU는 Tizen Application을 쉽게 개발할 수 있도록 도와주는 UI Framework로 모바일 뿐만 아니라 Galaxy Watch와 같은 시계 화면을 위한 Wearable을 지원하고 있다. 즉, TAU를 사용하면 아래와 같은 화면을 가진 앱을 쉽게 개발 할 수 있다 :D\r\n\r\n| ![](https://docs.tizen.org/application/web/api/5.5/images/DatePicker.png) | ![](https://docs.tizen.org/application/web/api/5.5/images/checkbox-wearable.png) |\r\n|:--:|:--:|\r\n\r\n## TAU 설치하기\r\n\r\nTAU는 오픈소스 프로젝트로 현재 github를 통해 [release](https://github.com/Samsung/TAU/releases)가 되고 있다. TAU를 사용하기 위해 먼저 소스를 [다운](https://github.com/Samsung/TAU/releases/tag/v1.0.27) 받아보자. 다운로드 페이지에는 다양한 버전이 릴리즈 되고 있지만 각 버전에 대한 차이점에 대해서는 다른 글을 통해 설명하도록 하겠다. 이 중에서 테스트를 위해 일단 1.0.27 버전을 [다운](https://github.com/Samsung/TAU/releases/download/v1.0.27/dist-1.0.27.zip) 받아보자.\r\n\r\n다운 받은 파일을 [#1](https://hs85jeong.github.io/tizen-1/)번째 글에서 생성한 BasicTest 폴더에 압축을 풀고 아래와 같이 TAU를 사용하기 위한 tau.css, tau.circle.css, tau.js를 header 부분에 포함시켜 주자.\r\n``` html\r\n<head>\r\n    <meta charset=\"utf-8\" />\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0\">\r\n    <meta name=\"description\" content=\"Tizen Wearable basic template generated by Samsung Wearable Web IDE\"/>\r\n\r\n    <title>Tizen Wearable Web IDE - Tizen Wearable - Tizen Wearable basic Application</title>\r\n\r\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"css/style.css\"/>\r\n\r\n    <!-- 아래 3줄을 여기에 넣어주세요 -->\r\n    <link rel=\"stylesheet\" type=\"text/css\" media=\"all and (-tizen-geometric-shape: circle)\" href=\"dist/wearable/theme/changeable/tau.css\"/>\r\n    <link rel=\"stylesheet\" type=\"text/css\" media=\"all and (-tizen-geometric-shape: circle)\" href=\"dist/wearable/theme/changeable/tau.circle.css\"/>\r\n    <script src=\"dist/wearable/js/tau.js\"></script>\r\n</head>\r\n```\r\n\r\nTAU를 포함 시켰다면 이제 TAU를 이용한 간단한 리스트를 만들어보도록 하자. 이번에는 아래 코드를 body 부분에 포함시켜 보도록 하자.\r\n\r\n``` html\r\n<body>  \r\n\t<div class=\"ui-page\">\r\n\t\t<div class=\"ui-content\">\r\n\t\t\t<ul class=\"ui-listview\">\r\n\t\t\t\t<li>List 01</li>\r\n\t\t\t\t<li>List 02</li>\r\n\t\t\t\t<li>List 03</li>\r\n\t\t\t\t<li>List 04</li>\r\n\t\t\t\t<li>List 05</li>\r\n\t\t\t</ul>\r\n\t\t</div>\r\n\t</div>\r\n\t<script>\r\n\t\tvar list = document.querySelector(\".ui-listview\");\r\n\t\ttau.widget.Listview(list);\r\n\t</script>\r\n</body>\r\n```\r\n\r\n코드를 전부 입력했다면 완성된 코드를 [#1](https://hs85jeong.github.io/tizen-1/)에서 진행한대로 \"Tizen Web: Build Tizen App\"를 한 뒤 \"Tizen Web: Install Tizen App\"를 통해 Emulator에서 실행해보면 아래 화면과 같이 Wearable 화면에 어울리는 List를 가진 앱 화면을 볼 수 있다.\r\n\r\n![](tizen1.png)\r\n\r\n\r\n이제 TAU를 사용할 준비는 마쳤다. 이제 본격적으로 TAU를 활용해서 만들 수 있는 Component들을 살펴 보도록 하자. \r\n\r\n\r\n","excerpt":"TAU 란? 일반적으로 Web Application은 html, css, js를 조합해서 개발을 하는데 Web…","fields":{"slug":"/tizen-2/"},"frontmatter":{"date":"Mar 24, 2020","title":"Galaxy Watch 앱 만들기 #2 - TAU (Tizen Advanced UI) 사용하기","tags":["Galaxy","Tizen","Gear","Watch","TAU","갤럭시워치","타이젠"]}}},{"node":{"rawMarkdownBody":"\r\n## 개발툴(IDE) 설치하기\r\n\r\nGalaxy Watch 앱을 개발하기 위해서는 개발툴(IDE) 설치가 먼저 필요한데, Galaxy Watch의 경우 Tizen OS를 사용하고 있으므로 [Tizen](https://www.tizen.org/)에서 제공하는 [Tizen Studio](https://developer.tizen.org/development/tizen-studio/download)를 사용해도 되지만 개인적으로 [VSCode](https://code.visualstudio.com/)를 주 개발툴로 사용하고 있기 때문에 VSCode Extension으로도 제공되는 Tizen Web Exetnsion을 사용하려고 한다. [VSCode를 설치](https://code.visualstudio.com/)한 뒤 Extensions: 마켓플레이스에 tizen web을 검색해 첫번째로 검색되는 [**Tizen Web**](https://marketplace.visualstudio.com/items?itemName=tizenweb.tizenweb)을 Install 해주면 된다.\r\n\r\n![tizen web](tizen_1.png)\r\n\r\n> Tizen Web Extension을 설치 한 후 관련 명령어를 검색하려면 명령 팔레트(Ctrl + Shift + P)를 띄운 후 tizen을 검색하면 된다.\r\n\r\n![command palette](tizen_2.png)\r\n\r\n제일 먼저 해줘야할 작업은 Baseline SDK를 설치해줘야 한다. \"Tizen Web: Install Tizen Baseline SDK\"를 실행해서 Baseline SDK를 설치해주도록 하자.\r\n\r\n## 프로젝트 생성\r\n\r\n먼저 개발환경이 제대로 설정 되었는 지를 확인해보기 위해 기본 프로젝트를 만들어보자. \"명령 팔레트 - Tizen Web: Create Wizard Project\"을 실행 주면 프로젝트 생성 Wizard가 실행이 되는데 Template과 Sample 중 일단 Template을 선택해보자.\r\n\r\n![template](tizen_3.png)\r\n\r\n\r\n그 다음으로 Wearable 용 앱을 만들거니 Wearable을 선택해주고 일단 Version 3.0을 선택해주다. Version과 관련된 설명도 다음에 추가하도록 하겠다.\r\n\r\n![wearable](tizen_4.png)\r\n\r\n\r\n선택된 버전의 Platform이 설치가 되어 있지 않을 경우 아래와 같이 우측 하단에 Popup이 뜨게 되는데 Yes를 눌러 Package Manager를 실행하여 Wearable 3.0 SDK를 설치해주도록 하자.\r\n\r\n![](tizen_5.png)\r\n![](tizen_5_1.png)\r\n\r\n\r\n> 혹시 설치되어 있는 Tizen SDK의 경로가 기본 경로에 설치되어 있지 않으면 아래와 같은 Popup이 나올 수 있는데 이럴 경우는 \"Tizen Web: Change Tizen SDK Path\"를 실행한 뒤 Change Path를 선택하여 설치된 경로를 바꿔주도록 하자.\r\n\r\n![](tizen_6.png)\r\n![](tizen_7.png)\r\n![](tizen_8.png)\r\n\r\n위 과정까지 문제 없이 마쳤다면 이제 거의 준비가 된 것 이다. 이제 Template 항목 중 기본 앱인 Basic UI앱을 만들어 선택해보자.\r\n\r\n![](tizen_9.png)\r\n\r\n드디어 마지막 생성할 앱의 이름을 정해주도록 하자. Basic UI 앱이니 BasicTest라는 이름을 적어 준 뒤 프로젝트 생성을 완료하면 된다.\r\n\r\n![](tizen_10.png)\r\n\r\n아래와 같이 생성된 프로젝트 파일들이 보인다면 생성이 제대로 완료 되었다는 것이다.\r\n\r\n![](tizen_11.png)\r\n\r\n## Emulator로 실행해보기\r\n\r\nEmulator를 실행하는 방법은 여러가지가 있지만 처음 시작할 경우에는 생성된 Emulator Image가 없기 때문에 Emulator Manager를 실행하여 테스트할 Image를 만들어 주도록 하자. Emulator Manager를 실행하기 위해서는 \"Tizen Web: Run Emulator-Manager\"를 실행하도록 하자.\r\n\r\n![](tizen_12.png)\r\n\r\n\"Create\"를 눌러 원하는 버전의 Emulator Image를 생성해야줘야 하는데 우리가 기본적으로 시작할 할 이미지는 wearable 3.0 버전의 이미지 이므로 선택 후 생성하도록 하자.\r\n\r\n![](tizen_13.png)\r\n\r\n\r\n> 생성 과정 중 중요한 부분 중 하나인 Emualtor의 경우 가상화 기술(VT)과 GPU가 켜져 있지 않을 경우 매우 느리게 실행이 된다. CPU VT의 경우 바이오스에서 VT 기능을 켜준 뒤 [Intel HAXM](https://developer.tizen.org/ko/development/tizen-studio/download/installing-tizen-studio/hardware-accelerated-execution-manager?langswitch=ko)을 설치해줘야 하고 GPU의 경우 그래픽카드가 제대로 설치되어 있다면 문제없이 ON할 수 있을 것 이다. 문제가 없다면 바로 이미지를 생성을 완료하도록 하자.\r\n\r\n![](tizen_14.png)\r\n\r\n이제 Emaulator 설정이 끝났다. 생성한 Emualtor Image을 Launch 해주도록 하자. 아래와 같이 시계화면이 나온다면 제대로 실행한 것이다.\r\n\r\n![](tizen_15.png)\r\n\r\n\r\n## App 실행 해보기\r\n\r\n테스트할 앱을 설치하기 위해서는 먼저 프로젝트를 빌드해줘야한다. VSCode 화면으로 돌아와 \"Tizen Web: Build Tizen App\"을 실행한 뒤 설치할 프로젝트를 선택해주도록 하자. 다음으로 빌드한 앱을 설치해보도록 하자. \"Tizen Web: Install Tizen App\"을 실행하면 앱이 설치가 되면서 자동으로 실행이 되게 된다. 아래와 같은 화면이 나오면 성공이다!\r\n\r\n![](tizen_16.png)\r\n\r\n자 이제 앱 개발을 시작해볼 수 있는 기본 환경은 갖추었다! 다음 글을 통해 어떻게 Wearable App들을 예쁘게 만들 수 있는지 배워보도록 하자!\r\n\r\n","excerpt":"개발툴(IDE) 설치하기 Galaxy Watch 앱을 개발하기 위해서는 개발툴(IDE) 설치가 먼저 필요한데, Galaxy Watch의 경우 Tizen OS를 사용하고 있으므로 Tizen에서 제공하는 Tizen Studio…","fields":{"slug":"/tizen-1/"},"frontmatter":{"date":"Mar 12, 2020","title":"Galaxy Watch 앱 만들기 #1 - 개발환경 설정","tags":["Galaxy","Tizen","Gear","Watch","갤럭시워치","타이젠"]}}},{"node":{"rawMarkdownBody":"\r\n혹시 Node.js 스크립트를 실행하면 어떤 방식으로 동작을 하는지 궁금하지 않았나요?\r\n\r\n이 글은 이런 궁금증을 가지고 있는 분들에게 조금이나마 도움이 되고자 하는 글이니, 관심이 없으시다면 스킵하셔도 됩니다 :D\r\n\r\n\r\n먼저, Node.js를 분석하기 위해서 코드를 다운 받아봅시다.\r\n\r\n``` javascript\r\n$ git clone https://github.com/nodejs/node.git && cd node\r\n```\r\n\r\nNode.js의 파일 구조는 아래와 같은 모습을 가지고 있습니다.\r\n\r\n``` bash\r\n$ tree -L 1\r\n.\r\n├── AUTHORS\r\n├── BSDmakefile\r\n├── BUILDING.md\r\n├── CHANGELOG.md\r\n├── CODE_OF_CONDUCT.md\r\n├── COLLABORATOR_GUIDE.md\r\n├── CONTRIBUTING.md\r\n├── CPP_STYLE_GUIDE.md\r\n├── GOVERNANCE.md\r\n├── LICENSE\r\n├── Makefile\r\n├── README.md\r\n├── SECURITY.md\r\n├── android-configure\r\n├── benchmark\r\n├── common.gypi\r\n├── configure\r\n├── configure.py\r\n├── deps\r\n├── doc\r\n├── lib           # JS sources\r\n├── node.gyp\r\n├── node.gypi\r\n├── src           # C++ sources\r\n├── test\r\n├── tools\r\n└── vcbuild.bat\r\n\r\n7 directories, 20 files\r\n```\r\n\r\n노드는 크게 2종류의 언어로 이루어져 있는데 `lib/` 폴더 안에 있는 JavaScript 파일 들과 `src/` 폴더 밑에 존재하는 많은 양의 C++ 파일 들이 있습니다. \r\n\r\nNode.js의 모든 시작 과정은 C++에서 완료되며, main 시작 지점은 `src/node_main.cc` 입니다.\r\n\r\n이 안에서 제일 중요한 부분은 다음과 같습니다.\r\n\r\n``` c++\r\nreturn node::Start(argc, argv);\r\n```\r\n\r\n이 것은 `src/node.cc`의 `Start`을 호출하고 command line의 parameter들을 `argc`와 `argv`로 넘겨줍니다.\r\n\r\n첫 번째 단계로 `Start()`안에서 런타임 초기화 작업들이 수행되는데 `InitializeOncePerProcess`는 환경변수(예.`NODE_OPTIONS`)나 CLI parameters(예.`--abort-on-uncaught-exception`)를 통해 주어지는 설정 값들을 처리하고 V8을 초기화 해준다. 한 번 이작업이 완료가 되면, 새로운 node 인스턴스들은 [libuv default loop](http://docs.libuv.org/en/v1.x/loop.html#c.uv_default_loop)를 사용해 초기화 된 후 마침내 아래와 같이 실행되게 됩니다.\r\n\r\n``` c++\r\nNodeMainInstance main_instance(&params,\r\n                               uv_default_loop(),\r\n                               per_process::v8_platform.Platform(),\r\n                               result.args,\r\n                               result.exec_args,\r\n                               indexes);\r\nresult.exit_code = main_instance.Run()\r\n```\r\n\r\n`NodeMainInstance::Run()`을 통해 Node를 실행 시 어떤 일들이 수행되는 지를 알 수 있는 길에 좀 더 가까워졌습니다. 새로운 메인 쓰레드 수행 환경이 `src/node_main_instance.cc`에서 만들어지는데:\r\n\r\n```c++\r\nstd::unique_ptr<Environment> env = CreateMainEnvironment(&exit_code);\r\n```\r\n\r\n이 `Environment` 인스턴스가 libuv와 V8을 접근 할 수 있는 Handle들을 가지고 있는 노드 프로세스의 중심 객체입니다.\r\n\r\n이 객체를 `LoadEnvironment`에 넘기면\r\n\r\n``` c++\r\nLoadEnvironment(env.get());\r\n```\r\nmain thread 수행이 시작된다:\r\n\r\n``` c++\r\nvoid LoadEnvironment(Environment* env) {\r\n  CHECK(env->is_main_thread());\r\n  USE(StartMainThreadExecution(env));\r\n}\r\n```\r\n\r\n이 부분에서 C++에서 JavaScript 수행으로 변경이 됩니다.\r\n\r\n``` c++\r\nMaybeLocal<Value> StartMainThreadExecution(Environment* env) {\r\n  if (NativeModuleEnv::Exists(\"_third_party_main\")) {\r\n    return StartExecution(env, \"internal/main/run_third_party_main\");\r\n  }\r\n\r\n  std::string first_argv;\r\n  if (env->argv().size() > 1) {\r\n    first_argv = env->argv()[1];\r\n  }\r\n\r\n  if (first_argv == \"inspect\" || first_argv == \"debug\") {\r\n    return StartExecution(env, \"internal/main/inspect\");\r\n  }\r\n\r\n  if (per_process::cli_options->print_help) {\r\n    return StartExecution(env, \"internal/main/print_help\");\r\n  }\r\n\r\n\r\n  if (env->options()->prof_process) {\r\n    return StartExecution(env, \"internal/main/prof_process\");\r\n  }\r\n\r\n  // -e/--eval without -i/--interactive\r\n  if (env->options()->has_eval_string && !env->options()->force_repl) {\r\n    return StartExecution(env, \"internal/main/eval_string\");\r\n  }\r\n\r\n  if (env->options()->syntax_check_only) {\r\n    return StartExecution(env, \"internal/main/check_syntax\");\r\n  }\r\n\r\n  if (!first_argv.empty() && first_argv != \"-\") {\r\n    return StartExecution(env, \"internal/main/run_main_module\");\r\n  }\r\n\r\n  if (env->options()->force_repl || uv_guess_handle(STDIN_FILENO) == UV_TTY) {\r\n    return StartExecution(env, \"internal/main/repl\");\r\n  }\r\n\r\n  return StartExecution(env, \"internal/main/eval_stdin\");\r\n}\r\n```\r\n\r\n`StartExecution`의 경우 두번째 인자로 넘겨지는 JS파일들을 읽고, 컴파일하고, 실행하는데 모든 파일은 `lib/` 폴더 밑에 있는데, 이중 관심있게 봐야하는 곳은 두 곳 입니다.\r\n\r\n``` c++\r\nif (!first_argv.empty() && first_argv != \"-\") {\r\n  return StartExecution(env, \"internal/main/run_main_module\");\r\n}\r\n```\r\n\r\n``` c++\r\nif (env->options()->force_repl || uv_guess_handle(STDIN_FILENO) == UV_TTY) {\r\n  return StartExecution(env, \"internal/main/repl\");\r\n}\r\n```\r\n\r\n`lib/internal/main/repl.js`와 `lib/internal/main/run_main_module.js` 두 스크립트 모두 중요한 시작 메소드인 `lib/internal/bootstrap/pre_execution.js`안의 `prepareMainThreadExecution`을 실행하는데, 이것은 여러 setup 작업들을 수행하는데 이 중 CommonJS와 ES module loader 초기화 역시 수행됩니다.\r\n\r\n`lib/internal/modules/cjs/loader.js`안의 `Module` 객체는 CommonJS loaders core이며 `initializeCJSLoader`는 `runMain`를 통해 `lib/internal/modules/run_main.js`안의 `executeUserEntryPoint`을 실행해줍니다.\r\n\r\nCommonJS module의 경우 `Module._load`로 새로운 `Module` 인스턴스를 생성하고 `load`를 호출 해주고 적절한 extension function이 module을 읽어오는데 사용됩니다.\r\n\r\n``` javascript\r\nModule._extensions[extension](this, filename);\r\n```\r\n\r\n`*.js` extension이 실제 파일을 읽고 컴파일 해줍니다.\r\n\r\n``` javascript\r\nconst content = fs.readFileSync(filename, 'utf8');\r\nmodule._compile(content, filename)\r\n```\r\n\r\n`module._compile`은 V8의 `ScriptCompiler:CompileFunctionInContext`를 호출하고 [node module wrapper](https://nodejs.org/api/modules.html#modules_the_module_wrapper)에 맞는 `exports`, `require`, `module`, `__filename`, `__dirname`을 넘겨줍니다.\r\n\r\n이렇게 불려진 function은 실행이 되고 결과를 리턴해줍니다:\r\n\r\n``` javascript\r\nresult = compiledWrapper.call(thisValue, exports, require, module,\r\n                              filename, dirname);\r\n```\r\n\r\n---\r\n\r\n다음으로 확인 해봐야할 부분은 [libuv eventloop](http://docs.libuv.org/en/v1.x/guide/basics.html#event-loops)입니다.\r\n\r\nJavaScript를 컴파일하고 실행한 후, node 인스턴스는 event loop를 시작해줍니다.\r\n\r\n``` c++\r\ndo {\r\n    uv_run(env->event_loop(), UV_RUN_DEFAULT);\r\n\r\n    per_process::v8_platform.DrainVMTasks(isolate_);\r\n\r\n    more = uv_loop_alive(env->event_loop());\r\n    if (more && !env->is_stopping()) continue;\r\n\r\n    if (!uv_loop_alive(env->event_loop())) {\r\n        EmitBeforeExit(env.get());\r\n    }\r\n\r\n    // Emit `beforeExit` if the loop became alive either after emitting\r\n    // event, or after running some callbacks.\r\n    more = uv_loop_alive(env->event_loop());\r\n} while (more == true && !env->is_stopping());\r\n```\r\n\r\n[uv_run_mode](http://docs.libuv.org/en/v1.x/loop.html#c.uv_run_mode) `UV_RUN_DEFAULT`는 더이상 동작하거나 참조되는 곳이 없을때 까지 event loop를 수행합니다.\r\n\r\nlibuv는 lifetime에 따라 handle과 request로 구분이 되는데, 오랫동안 수행되는 객체의 경우 handle이라고 할 수 있고 짧은 시간동안 수행되는 operation들을 request라고 할 수 있습니다.\r\n\r\n``` javascript\r\nconst http = require('http');\r\n\r\nconst requestHandler = (req, res) => {\r\n  res.write('Hello World!');\r\n  res.end();\r\n};\r\n\r\nconst server = http.createServer(requestHandler);\r\n\r\nserver.listen(8080);\r\n```\r\n\r\n위 예제의 경우 `requestHandler`를 libuv request로 볼 수 있습니다. 반면, `server` 객체의 `listen`은 handle이라고 할 수 있습니다.\r\n\r\nHTTP server를 멈추지 않는 이상, libuv는 계속해서 실행되고 입력되는 연결들을 처리할 것 입니다.\r\n\r\n---\r\n\r\n\r\n위 과정들이 Node.js에서 스크립트가 어떻게 수행되는 지를 설명한 내용입니다. 물론, 전체 과정을 상세히 다루는게 아니기 때문에 설명이 부족한 부분이 있을 수 있겠지만, 스크립트가 수행되는 과정에서의 중요한 부분들을 설명해주고 있습니다.\r\n\r\n혹시 기회가 된다면 다음 포스트를 통해 추가적인 내용들을 다루어 보겠습니다.\r\n\r\n---\r\n\r\n## Reference\r\n[Inside node: What happens when we execute a script?](https://blog.s1h.org/inside-node-executing-a-script/)\r\n","excerpt":"혹시 Node.js 스크립트를 실행하면 어떤 방식으로 동작을 하는지 궁금하지 않았나요? 이 글은 이런 궁금증을 가지고 있는 분들에게 조금이나마 도움이 되고자 하는 글이니, 관심이 없으시다면 스킵하셔도 됩니다 :D 먼저, Node.js…","fields":{"slug":"/node-internal/"},"frontmatter":{"date":"Feb 16, 2020","title":"Node.js에서 스크립트가 실행될 때 어떤 일들이 일어날까요?","tags":["Node.js"]}}}]}},"pageContext":{}}}